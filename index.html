<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lane Cove Open 2025 - Season 2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/javascript">
      const { useState, useEffect } = React;

      function TournamentApp() {
        const [players, setPlayers] = useState([
          "Player 1 & 2",
          "Player 3 & 4",
          "Player 5 & 6",
          "Player 7 & 8"
        ]);
        const [newPlayer, setNewPlayer] = useState("");
        const [matches, setMatches] = useState([]);
        const [roundsCount, setRoundsCount] = useState(0);

        const [semis, setSemis] = useState([]);
        const [final, setFinal] = useState([]);
        const [champion, setChampion] = useState("");

        // --- Broadcast via localStorage ---
        useEffect(() => {
          const storedMatches = localStorage.getItem("matches");
          if (storedMatches) setMatches(JSON.parse(storedMatches));
          const storedSemis = localStorage.getItem("semis");
          if (storedSemis) setSemis(JSON.parse(storedSemis));
          const storedFinal = localStorage.getItem("final");
          if (storedFinal) setFinal(JSON.parse(storedFinal));
          const storedChampion = localStorage.getItem("champion");
          if (storedChampion) setChampion(storedChampion);
        }, []);

        useEffect(() => localStorage.setItem("matches", JSON.stringify(matches)), [matches]);
        useEffect(() => localStorage.setItem("semis", JSON.stringify(semis)), [semis]);
        useEffect(() => localStorage.setItem("final", JSON.stringify(final)), [final]);
        useEffect(() => localStorage.setItem("champion", champion), [champion]);

        // --- Round-robin generator ---
        function generateRoundRobin(names) {
          const n = names.length;
          if (n < 2) return [];
          const list = [...names];
          if (n % 2 === 1) list.push("BYE");
          const rounds = list.length - 1;
          const half = list.length / 2;
          let arr = [...list];
          const schedule = [];

          for (let r = 0; r < rounds; r++) {
            for (let i = 0; i < half; i++) {
              const a = arr[i], b = arr[arr.length - 1 - i];
              if (a !== "BYE" && b !== "BYE") {
                schedule.push({ round: r + 1, playerA: a, playerB: b, scoreA: "", scoreB: "", winner: null });
              }
            }
            arr = [arr[0], arr[arr.length - 1], ...arr.slice(1, -1)];
          }
          return schedule;
        }

        function handleGenerateSchedule() {
          const s = generateRoundRobin(players);
          setMatches(s);
          setRoundsCount(players.length % 2 === 0 ? players.length - 1 : players.length);
          setSemis([]);
          setFinal([]);
          setChampion("");
        }

        function updateMatch(idx, field, value) {
          setMatches(m =>
            m.map((x,i) => {
              if (i !== idx) return x;
              const upd = { ...x, [field]: value };
              const a = parseFloat(upd.scoreA), b = parseFloat(upd.scoreB);
              if (!isNaN(a) && !isNaN(b)) {
                if (a > b) upd.winner = upd.playerA;
                else if (b > a) upd.winner = upd.playerB;
                else upd.winner = "DRAW";
              }
              return upd;
            })
          );
        }

        function standings() {
          const table = {};
          players.forEach(p => table[p] = { name: p, played: 0, wins: 0, losses: 0, draws: 0, score: 0 });
          matches.forEach(m => {
            if (!m.winner) return;
            table[m.playerA].played++;
            table[m.playerB].played++;
            if (m.winner === m.playerA) { table[m.playerA].wins++; table[m.playerB].losses++; table[m.playerA].score += 2; }
            else if (m.winner === m.playerB) { table[m.playerB].wins++; table[m.playerA].losses++; table[m.playerB].score += 2; }
            else { table[m.playerA].draws++; table[m.playerB].draws++; table[m.playerA].score++; table[m.playerB].score++; }
          });
          return Object.values(table).sort((a,b)=> b.score - a.score || b.wins - a.wins || a.name.localeCompare(b.name));
        }

        // --- Generate Playoffs ---
        function generatePlayoffs() {
          const top4 = standings().slice(0,4).map(s => s.name);
          const newSemis = [
            { playerA: top4[0], playerB: top4[3], scoreA: "", scoreB: "", winner: null },
            { playerA: top4[1], playerB: top4[2], scoreA: "", scoreB: "", winner: null }
          ];
          setSemis(newSemis);
          setFinal([]);
          setChampion("");
        }

        function updatePlayoff(set, idx, field, value) {
          set(prev => prev.map((x,i)=>{
            if(i!==idx) return x;
            const upd = {...x,[field]:value};
            const a=parseFloat(upd.scoreA), b=parseFloat(upd.scoreB);
            if(!isNaN(a)&&!isNaN(b)){
              if(a>b) upd.winner=upd.playerA;
              else if(b>a) upd.winner=upd.playerB;
              else upd.winner="DRAW";
            }
            return upd;
          }))
        }

        useEffect(()=>{
          if(semis.length===2 && semis.every(m=>m.winner)){
            setFinal([{ playerA: semis[0].winner, playerB: semis[1].winner, scoreA:"", scoreB:"", winner:null }])
          }
        }, [semis]);

        useEffect(()=>{
          if(final.length===1 && final[0].winner){
            setChampion(final[0].winner);
          }
        }, [final]);

        return (
          <div className="max-w-6xl mx-auto bg-white shadow rounded-lg p-6 my-6">
            <h1 className="text-3xl font-bold mb-6 text-center">Lane Cove Open 2025 - Season 2</h1>

            {/* Teams */}
            <section className="mb-6">
              <h2 className="font-semibold">Teams</h2>
              <div className="flex gap-2 mt-2">
                <input className="border rounded px-2 py-1 flex-1" placeholder="Add team"
                  value={newPlayer}
                  onChange={e=>setNewPlayer(e.target.value)}
                  onKeyDown={e=>{ if(e.key==="Enter" && newPlayer.trim()){ setPlayers(p=>[...p,newPlayer.trim()]); setNewPlayer("") } }}
                />
                <button className="px-3 py-1 bg-blue-600 text-white rounded"
                  onClick={()=>{if(newPlayer.trim()){ setPlayers(p=>[...p,newPlayer.trim()]); setNewPlayer("") }}}>Add</button>
              </div>
              <div className="mt-3 grid grid-cols-2 md:grid-cols-4 gap-2">
                {players.map((p,i)=>(
                  <div key={i} className="flex items-center gap-2 border rounded p-2">
                    <div className="flex-1">{p}</div>
                    <button className="text-sm px-2 py-1 bg-red-500 text-white rounded"
                      onClick={()=> setPlayers(prev=>prev.filter((_,idx)=>idx!==i))}>Remove</button>
                  </div>
                ))}
              </div>
              <div className="mt-3 flex gap-2">
                <button className="px-3 py-1 bg-indigo-600 text-white rounded" onClick={handleGenerateSchedule}>Generate Round-Robin</button>
                <button className="px-3 py-1 bg-green-600 text-white rounded" onClick={generatePlayoffs}>Generate Semi-Finals & Final</button>
              </div>
            </section>

            {/* Matches & Standings */}
            {/* ... You can reuse your previous matches + standings rendering ... */}

            {/* Ladder / Playoffs */}
            {/* ... You can reuse your previous ladder rendering ... */}
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<TournamentApp />);
    </script>
  </body>
</html>
